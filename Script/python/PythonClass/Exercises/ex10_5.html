<html>
<head>
<title>Python Training Exercises - Exercise 10.5</title>
</head>

<body>
<h1>Exercise 10.5</h1>


<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
<li>Learn about class variables, static methods, and class methods</li>
</ul>
<p>
<b>Files Created:</b> <tt>dateobj.py</tt>

</td>
</tr>
</table>

<p>
Start this exercise by creating a file <tt>dateobj.py</tt> and
defining the following class that represents a date.</p>

<blockquote><table><tr><td><pre>
# dateobj.py

class Date(object):
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day
    def format(self):
        return "%d-%d-%d" % (self.year, self.month, self.day)
</pre></td></tr></table>
</blockquote>

<p>
Try your new object:</p>

<blockquote>
<pre>
>>> <b>d = Date(2010,4,13)</b>
>>> <b>d.format()</b>
'2010-4-13'
>>>
</pre>
</blockquote>

<p>
<b>(a) Class Methods</b>
</p>

<p>
A common use of class methods is to provide alternate constructors
(epecially since Python doesn't support overloaded methods).    Modify
the <tt>Date</tt> class to have a class method <tt>today()</tt> that
creates a date from today's date.</p>

<blockquote>
<pre>
>>> <b>d = Date.today()</b>
>>> <b>d.format()</b>
'2011-8-15'           # Output will vary--should be today
>>>
</pre>
</blockquote>

<p>Note: To get today's date, use the <tt>time</tt> module.</p>

<blockquote>
<pre>
>>> <b>import time</b>
>>> <b>t = time.localtime()</b>
>>> <b>t.tm_year, t.tm_mon, t.tm_mday</b>
(2010, 4, 1)
>>>
</pre>
</blockquote>

<p>
One reason you should use class methods for this is that they work
with inheritance.  For example, try this:</p>

<blockquote>
<pre>
>>> <b>class CustomDate(Date):
        def format(self):
            return "%d/%d/%d" % (self.month, self.day, self.year)</b>

>>> <b>d = CustomDate.today()</b>
>>> <b>d.format()</b>
'8/15/2011'
>>>
</pre>
</blockquote>

<p>
<b>(b) What about static methods?</b>
</p>

<p>
A static method is just a simple function that happens to be placed
in a class definition. However, unlike a normal method, it doesn't
operate on instances (e.g., there is no self parameter).   For
example, maybe you had some kind of utility method related to dates,
but not specific to <tt>Date</tt> instances like this:</p>

<blockquote><table><tr><td><pre>
class Date(object):
    ...
    @staticmethod
    def parse_ymd(s):
        '''Parse a date string and return a (year,month,day) tuple'''
        formats = ['%Y-%m-%d','%m/%d/%y']
        for fmt in formats:
            try:
                tm = time.strptime(s,fmt)
                break
            except ValueError:
                pass
        else:
            raise ValueError("Unrecognized format")
        return (tm.tm_year, tm.tm_mon, tm.tm_mday)
</pre></td></tr></table>
</blockquote>

<p>
To use this method, you just call it through the <tt>Date</tt> class
like this (notice no instance is used):</p>

<blockquote>
<pre>
>>> <b>year,mon,day = Date.parse_ymd("2011-08-04")</b>
>>> <b>year</b>
2011
>>> <b>mon</b>
8
>>> <b>day</b>
4
>>> <b>Date.parse_ymd("8/4/2011")</b>
(2011, 8, 4)
>>>
</pre>
</blockquote>

<p>Although C++ and Java programmers use static methods with some regularity, they are
not so common in Python code.  In part, if you just want a simple
procedure as shown, it's usually easy enough to just define it at the module level
instead of adding the extra complexity of sticking it in a
class--especially since modules already provide an enclosing namespace.
</p>


<hr>
[ <a href="index.html">Index</a> | <a
href="soln10_5.html">Solution</a>
| <a href="ex10_4.html">Back</a> | <a href="ex10_6.html">Next</a> ]
</body>
</html>
