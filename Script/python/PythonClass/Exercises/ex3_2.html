<html>
<head>
<title>Python Training Exercises - Exercise 3.2</title>
</head>

<body>
<h1>Exercise 3.2</h1>

<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
<li>Learn how to create more general purpose utility functions.
<li>Defining functions with default parameters.
</ul>
<p>
<b>Files Created:</b> <tt>PythonClass/fieldparse.py</tt>

<p>
<b>Files Modified:</b> None.
</td>
</tr>
</table>

<p>

A central part of your <tt>report.py</tt> program focuses on the reading of column-oriented data files.  For
example, the function <tt>read_portfolio()</tt> reads a file containing rows of portfolio data and
the function <tt>read_prices()</tt> reads a file containing rows of price data.   Both functions have a 
certain amount of shared functionality.  For example, they both loop over a file line-by-line, they both
split each line into a list of fields, and they both convert various field values into integers or floats.

<p>
In this exercise, we're going to design a general purpose parsing function that can be used
to read column-oriented datafiles. 

<p>
Start this exercise by creating a new file called <tt>fieldparse.py</tt>.  This is where we will be
doing our work.

<p>
<b>(a) A General Purpose Parsing Function</b>

<p>
In the <tt>fieldparse.py</tt> file, define a 
function <tt>parse(lines,types,names)</tt> that parses a sequence of lines
containing column oriented data into a list of dictionaries where the
user specifies type conversions and field names for the data.</p>

<p>
Here is how it should work:</P>

<blockquote>
<pre>
>>> <b>portfolio = parse(open("Data/portfolio.dat"),
                      [str,int,float],
                      ['name','shares','price'])</b>
>>> <b>for s in portfolio:
         print s</b>

{'price': 32.2, 'name': 'AA', 'shares': 100}
{'price': 91.1, 'name': 'IBM', 'shares': 50}
{'price': 83.44, 'name': 'CAT', 'shares': 150}
{'price': 51.23, 'name': 'MSFT', 'shares': 200}
{'price': 40.37, 'name': 'GE', 'shares': 95}
{'price': 65.10, 'name': 'MSFT', 'shares': 50}
{'price': 70.44, 'name': 'IBM', 'shares': 100}
>>>
</pre>
</blockquote>

<p>
You already implemented the basic mechanics of the type conversion and dictionary creation in
<a href="ex2_6.html">Exercise 2.6</a>.   Use that code as a guide for
writing the function.</p>

<P>To test your function, try the example shown above and make
sure it works exactly as shown.</p>

<p>
<b>(b) Making Some Parsing Enhancements</b>
</p>

<p>
Try using your <tt>parse()</tt> function on a file that contains
a lot of blank lines:</p>

<blockquote>
<pre>
>>> <b>portfolio = parse(open("Data/portfolioblank.dat"),
                      [str,int,float],
                      ['name','shares','price'])</b>
>>> <b>for s in portfolio:
         print s</b>

{'price': 32.2, 'name': 'AA', 'shares': 100}
{}
{'price': 91.1, 'name': 'IBM', 'shares': 50}
{}
{'price': 83.44, 'name': 'CAT', 'shares': 150}
{}
...
>>>
</pre>
</blockquote>
<p>In this output, you will notice that there are a lot of empty dictionaries. These 
dictionaries are the result of parsing blank lines of input where there are no columns of data to convert.
In practice, you would probably want to just ignore the empty lines.
</p>

<p>
Modify the <tt>parse()</tt> function so that it strips excess
whitespace from each line and ignores lines that are blank.  Test the
function on the <tt>Data/portfolioblank.dat</tt> file like this:</p>

<blockquote>
<pre>
>>> <b>portfolio = parse(open("Data/portfolioblank.dat"),
                      [str,int,float],
                      ['name','shares','price'])</b>
>>> <b>for s in portfolio:
         print s</b>

{'price': 32.2, 'name': 'AA', 'shares': 100}
{'price': 91.1, 'name': 'IBM', 'shares': 50}
{'price': 83.44, 'name': 'CAT', 'shares': 150}
{'price': 51.23, 'name': 'MSFT', 'shares': 200}
{'price': 40.37, 'name': 'GE', 'shares': 95}
{'price': 65.1, 'name': 'MSFT', 'shares': 50}
{'price': 70.44, 'name': 'IBM', 'shares': 100}
>>>
</pre>
</blockquote>

<p>
Sometimes fields of data are enclosed by double quotes.  For example:
</p>

<blockquote>
<pre>"AA" 50 35.20
</pre>
</blockquote>

What happens if you try your <tt>parse()</tt> function on a file with quotes like this?  Try it:

<blockquote>
<pre>
>>> <b>portfolio = parse(open("Data/portfolioquote.dat"),
                      [str,int,float],
                      ['name','shares','price'])</b>
(see what happens. hint: it crashes)
>>>
</pre>
</blockquote>

Strings have a method <tt>s.strip()</tt> that can be used to strip characters
from the beginning and end of a string.  Try it out:

<blockquote>
<pre>
>>> <b>field = '"AA"'</b>    # Note: " character is part of the string data
>>> <b>field.strip('"')</b>
'AA'
>>>
</pre>
</blockquote>

<p>
If you wanted to strip the quotes off of an entire list of fields, use
a list comprehension:
</p>

<blockquote>
<pre>
>>> <b>fields = [f.strip('"') for f in fields]</b>
>>>
</pre>
</blockquote>

<p>
Modify the <tt>parse()</tt> function to strip double quotes off of the beginning and end of each field (if any).
To test our your new version, try the above example again and make
sure it works.</p>

<p>
<b>(c) Default Arguments</b>
</p>

<p>
Currently, the <tt>parse()</tt> function always returns a list of
dictionaries.   However, suppose you wanted to have a list of tuples
instead?</p>

Modify the code so that
the column names parameter is optional.   If not specified, have the function
simply return a list of tuples instead.  For example:
</p>

<blockquote>
<pre>
>>> <b>portfolio = parse(open("Data/portfolio.dat"),[str,int,float])</b>
>>> <b>for s in portfolio:
         print s</b>

('AA', 100, 32.2)
('IBM', 50, 91.1)
('CAT', 150, 83.44)
...
>>>
</pre>
</blockquote>

<p>
Next, add an optional argument <tt>sep</tt> that allows a user to specify a different
column separator character.  For example:
</p>

<blockquote>
<pre>
>>> <b>portfolio = parse(open("Data/portfolio.csv"),[str,int,float],sep=',')</b>
>>> <b>for s in portfolio:
         print s</b>

('AA', 100, 32.2)
('IBM', 50, 91.1)
('CAT', 150, 83.44)
...
>>>
</pre>
</blockquote>

<p>
Note:   Set <tt>sep=None</tt> and use <tt>line.strip(sep)</tt> to
split on whitespace as before.
</p>

<p>
By now, your parsing function is really starting to be useful.  Ponder
the fact that very little code is involved in the solution.
</p>

<p>
<b>(d) Keeping your options open</b>

<p>
One thing you might be wondering about is why the <tt>open()</tt>
operation in the above examples isn't performed inside the <tt>parse()</tt>
function.  Isn't it kind of a pain to require the user to always
open the input file?

<p>
One reason for this design is that it gives us greater flexibility on
how files are opened.  For example, if you want to parse a gzip
compressed data file.  You might do this instead.

<blockquote>
<pre>
>>> <b>import gzip</b>
>>> <b>portfolio =  parse(gzip.open("Data/portfolio.gz"),[str,int,float])</b>
>>>
</pre>
</blockquote>

<p>
If you wanted to read prices off of a web site, you might do this:
</p>

<blockquote>
<pre>
>>> <b>import urllib</b>
>>> <b>pricelist =parse(urllib.urlopen("http://finance.yahoo.com/d/quotes.csv?s=@^DJI&f=sl1"),
                         [str,float],sep=',')</b>
>>> <b>for p in pricelist:
        print p</b>

... look at the output ...
>>>
</pre>
</blockquote>

<p>
This wouldn't be possible if the <tt>open()</tt> were moved
inside the <tt>parse()</tt> function where it couldn't be changed.</p>

<p>
Take a moment to convert the above list of prices into a dictionary 
of prices.  This is easy--any sequence of pairs can be converted using 
<tt>dict()</tt>.

<blockquote>
<pre>
>>> <b>prices = dict(pricelist)</b>
>>> <b>prices</b>
... look at the output ...
>>> <b>prices['IBM']</b>
</pre>
</blockquote>

<p>
<b>An important note about files</b>
</p>

<p>
In this exercise, you might wonder about the use of the
<tt>open()</tt> function without explicitly calling <tt>close()</tt>
on the created file.  For the greatest reliability in code, you
should probably write your code as follows:
</p>

<blockquote>
<pre>
>>> <b>f = open("Data/portfolio.dat")</b>
>>> <b>portfolio = parse(f,[str,int,float],['name','shares','price'])</b>
>>> <b>f.close()</b>
>>>
</pre>
</blockquote>

<p>
Or alternatively:
</p>

<blockquote>
<pre>
>>> <b>with open("Data/portfolio.dat") as f:</b>
         <b>portfolio = parse(f,[str,int,float],['name','shares','price'])</b>

>>> 
</pre>
</blockquote>

<p>
If you forget to close a file, it will still be closed when the file
object is garbage collected by the interpreter.  However, garbage
collection is a funny thing--you don't really know when it might take
place.  Thus, the file might be held open for an indeterminate length
of time.   Your best bet is to always close it explicitly when you're
done using it.
</p>

<hr>
[ <a href="index.html">Index</a> | <a href="soln3_2.html">Solution</a>
| <a href="ex3_1.html">Back</a> | <a href="ex3_3.html">Next</a> ]
</body>
</html>
