<html>
<head>
<title>Python Training Exercises - Exercise 4.5</title>
</head>

<body>
<h1>Exercise 4.5</h1>

<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
<li>Simple XML parsing.</li>
<li>Simple JSON parsing.</li>
<li>Simple binary data handling.</li>
</ul>

<p>
<b>Files Created:</b> None

<p>
<b>Files Modified:</b> None
</p>
</td>
</tr>
</table>


<p>
<b>(a) Simple XML Parsing</b>
</p>

<p>
The file <tt>Data/allroutes.xml</tt> contains an XML file representing
a snapshot of the latitude and longitude position
of all GPS-equipped city buses in Chicago (data which is available as a real-time download).   The
file looks something like this:</p>

<blockquote>
<pre>
&lt;?xml version="1.0"?>
&lt;buses>
  &lt;bus>
    &lt;id>7574&lt;/id>
    &lt;route>147&lt;/route>
    &lt;color>#3300ff&lt;/color>
    &lt;revenue>true&lt;/revenue>
    &lt;direction>North Bound&lt;/direction>
    &lt;latitude>41.925682067871094&lt;/latitude>
    &lt;longitude>-87.63092803955078&lt;/longitude>
    &lt;pattern>2499&lt;/pattern>
    &lt;patternDirection>North Bound&lt;/patternDirection>
    &lt;run>P675&lt;/run>
    &lt;finalStop>&lt;![CDATA[Paulina & Howard Terminal]]>&lt;/finalStop>
    &lt;operator>42493&lt;/operator>  
  &lt;/bus>
  &lt;bus>
    &lt;id>6842&lt;/id>
    &lt;route>81&lt;/route>
    &lt;color>#996633&lt;/color>
    &lt;revenue>true&lt;/revenue>
    &lt;direction>East Bound&lt;/direction>
    &lt;latitude>41.96847915649414&lt;/latitude>
    &lt;longitude>-87.71509087085724&lt;/longitude>
    &lt;pattern>1649&lt;/pattern>
    &lt;patternDirection>East Bound&lt;/patternDirection>
    &lt;run>F259&lt;/run>
    &lt;finalStop>&lt;![CDATA[Marine Drive & Wilson]]>&lt;/finalStop>
    &lt;operator>40641&lt;/operator>  
  &lt;/bus>
  ...
&lt;/buses>
</pre>
</blockquote>

<p>
Let's use the <tt>ElementTree</tt> library to find out where all of
the Route-22 buses are currently located along with their direction.
</p>

<blockquote>
<pre>
>>> <b>from xml.etree.ElementTree import parse</b>
>>> <b>buses = parse("Data/allroutes.xml")</b>
>>> <b>for bus in buses.findall("bus"):
      if bus.findtext("route") == '22':
            lat = bus.findtext("latitude")
            lon = bus.findtext("longitude")
            direction = bus.findtext("direction")
            print lat, lon, direction</b>

41.99031664530436 -87.67012786865234 South Bound
41.87956511974335 -87.63079524040222 South Bound
41.880481123924255 -87.62948191165924 North Bound
... more output ...
>>>
</pre>
</blockquote>

<p>
<b>SPECIAL TOPIC:</b> <a href="xml.html">Advanced XML</a> (optional)
</p>

<p>
<b>(b) Decoding JSON</b>
</p>

<p>
Go find the last 10 tweets that mention the word "python" on Twitter
by issuing the following request:</p>

<blockquote>
<pre>
>>> <b>import urllib</b>
>>> <b>u = urllib.urlopen("http://search.twitter.com/search.json?q=python&rpp=10")</b>
>>> <b>rawdata = u.read()</b>
>>> <b>print rawdata</b>
... look at the output (JSON) ...
>>>
</pre>
</blockquote>

<p>
Parse the resulting data as JSON:
</p>

<blockquote>
<pre>
>>> <b>import json</b>
>>> <b>data = json.loads(rawdata)</b>
>>> <b>print data</b>
... look at the output ...
>>>
</pre>
</blockquote>

<p>
Print the actual tweets:
</p>

<blockquote>
<pre>
>>> <b>for tw in data['results']:
         print tw['text'].encode('ascii','replace')
         print</b>

... look at the output ...
>>>
</pre>
</blockquote>

<p>
The use of <tt>encode()</tt> in the above code is to account for
tweets containing non-ascii Unicode characters.   For now, the code
simply replaces them with the '?' character.
</p>

<P>
<b>(c) Reading Binary-Encoded Records</b>
</p>

<p>
The file <tt>Data/portfolio.bin</tt> contains portfolio data
in a packed binary format. Each record is stored as follows:

<blockquote>
<pre>
Bytes          Size             Description
-------------------------------------------
0-7            8 bytes          Name of stock (string)
8-11           4 bytes          Number of shares (32-bit integer, little endian)
12-15          4 bytes          Price (32-bit float, little endian)
</pre>
</blockquote>

<p>
Let's try reading some of this data:
</p>

<blockquote>
<pre>
>>> <b>import struct</b>
>>> <b>f = open("Data/portfolio.bin","rb")</b>
>>> <b>rawrecord = f.read(16)</b>      # Get a raw 16-byte record
>>> <b>rawrecord</b>
'AA\x00\x00\x00\x00\x00\x00d\x00\x00\x00\xcd\xcc\x00B'
>>> <b>name,shares,price = struct.unpack("<8sif",rawrecord)</b>
>>> <b>name</b>
'AA\x00\x00\x00\x00\x00\x00'
>>> <b>shares</b>
100
>>> <b>price</b>
32.20000076293945
>>> 
</pre>
</blockquote>

<p>
Let's strip the padding off of the name and make a dictionary:
</p>

<blockquote>
<pre>
>>> <b>name = name.strip('\x00')</b>
>>> <b>name</b>
'AA'
>>> <b>s = { 'name': name, 'shares' : shares, 'price' :price }</b>
>>> <b>s</b>
{'price': 32.20000076293945, 'name': 'AA', 'shares': 100}
>>> 
</pre>
</blockquote>

<p>
To read the rest of the file, you would continue to read the file in
16-byte chunks and decode as shown. For example:
</p>

<blockquote>
<pre>
>>> <b>while True:
       rawrecord = f.read(16)
       if not rawrecord:
            break
       name, shares, price = struct.unpack("<8sif",rawrecord)
       name = name.strip('\x00')
       print name, shares, price
</b>
IBM 50 91.0999984741
CAT 150 83.4400024414
MSFT 200 51.2299995422
GE 95 40.3699989319
MSFT 50 65.0999984741
IBM 100 70.4400024414
>>>
</pre>
</blockquote>

<hr>
[ <a href="index.html">Index</a> | <a href="soln4_5.html">Solution</a>
| <a href="ex4_4.html">Back</a> | <a href="ex4_6.html">Next</a> ]
</body>
</html>
