<html>
<head>
<title>Python Training Exercises - Exercise 5.2</title>
</head>

<body>
<h1>Exercise 5.2</h1>

<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
<li>Learn how to use inheritance to write extensible code.
<li>See a practical use of inheritance by writing a program that must
output data in a variety of user-selectable formats such as plain-text,
HTML, and CSV.
</ul>
<p>
<b>Files Created:</b> None

<p>
<b>Files Modified:</b> <tt>PythonClass/stock.py</tt>

</td>
</tr>
</table>

<p>
Inheritance is a mechanism that allows you to take an existing class
and add or redefine some of its methods.  For example, you can try
this simple example using your <tt>Stock</tt> class:</p>

<blockquote>
<pre>
>>> <b>from stock import Stock</b>
>>> <b>class MyStock(Stock):
        def yow(self):
            print "Yow!"</b>

>>> <b>s = MyStock('GOOG',100,490.10)</b>
>>> <b>s.cost()</b>
49010.0
>>> <b>s.yow()</b>
Yow!
>>>
</pre>
</blockquote>

<P>
If you are so inclined, you can also inherit from Python's built-in
types.  For example:</p>

<blockquote>
<pre>
>>> <b>class myint(int):
        def yow(self):
            print "Yow!"</b>

>>> <b>x = myint(42)</b>
>>> <b>x</b>
42
>>> <b>x.yow()</b>
Yow!
>>>
</pre>
</blockquote>

<p>
Just because you can inherit from other classes doesn't mean that it's
a feature you use gratuitously. In practice, proper use of inheritance is often
a lot trickier than it looks.</p>

<p>
That said, one major use of inheritance is in writing code that's
meant to be extended or customized in various ways--especially in
libraries or frameworks. Add the following function to your <tt>stock.py</tt> program:

<blockquote>
<table><tr><td>
<pre>
# stock.py
...
def print_table(portfolio):
    '''
    Make a nicely formatted table showing portfolio contents.
    '''
    headers = ('Name','Shares','Price')
    for h in headers:
        print "%10s" % h,
    print
    print ("-"*10 + " ")*len(headers)
    for s in portfolio:
        print "%10s %10d %10.2f" % (s.name, s.shares, s.price)
</pre>
</td></tr></table>
</blockquote>

<p>
Add a little testing section to the bottom of your <tt>stock.py</tt>
file that runs the above function:
</p>

<blockquote>
<table><tr><td>
<pre>
if __name__ == '__main__':
    portfolio = read_portfolio("Data/portfolio.dat")
    print_table(portfolio)
</pre>
</td></tr></table>
</blockquote>

<p>When you run your <tt>stock.py</tt>, you should get this output:

<blockquote>
<pre>
      Name     Shares      Price
---------- ---------- ---------- 
        AA        100      32.20
       IBM         50      91.10
       CAT        150      83.44
      MSFT        200      51.23
        GE         95      40.37
      MSFT         50      65.10
       IBM        100      70.44
</pre>
</blockquote>

<p>
<b>(a) An Extensibility Problem</b>
</p>
<p>
Suppose that you wanted to modify the <tt>print_table()</tt> function to be able to generate the
table in a variety of formats such as plain-text, HTML, CSV, or XML.
To do this, you could try to write one gigantic function that did
everything.  However, doing so would likely lead to an unmaintainable
mess.   Instead, this is a perfect opportunity to define a class and use inheritance.
</p>

<p>
To start, take the above <tt>print_table()</tt> function
and turn it into a method of a class definition like this:</p>

<blockquote>
<table><tr><td>
<pre>
# stock.py
...
class PortfolioPrinter(object):
    '''
    Output portfolio data in plain-text format.
    '''
    def print_table(self,portfolio):
        '''
        Make a nicely formatted table showing portfolio contents.
        '''
        headers = ('Name','Shares','Price')
        for h in headers:
            print "%10s" % h,
        print
        print ("-"*10 + " ")*len(headers)
        for s in portfolio:
            print "%10s %10d %10.2f" % (s.name, s.shares, s.price)
</pre>
</td></tr></table>
</blockquote>

<p>
Try your new class by modifying the main program like this:
</p>

<blockquote>
<table><tr><td>
<pre>
if __name__ == '__main__':
    portfolio = read_portfolio("Data/portfolio.dat")
    printer = PortfolioPrinter()
    printer.print_table(portfolio)
</pre>
</td></tr></table>
</blockquote>

<p>
When you run this new code, you should get exactly the same output as
before.
</p>

<p>
<b>(b) Adding Methods</b>
</p>

<p>
The <tt>print_table()</tt> method consists of two parts: code that
produces the table header and code that produces the different rows
of the table.  Take this functionality and put it in two methods,
<tt>headings(headers)</tt> and <tt>row(rowdata)</tt> like this:
</p>

<blockquote>
<table><tr><td>
<pre>
# stock.py
...
class PortfolioPrinter(object):
    ...
   def headings(self,headers):
       '''
       Emit the table headings.
       '''
       for h in headers:
           print "%10s" % h,
       print
       print ("-"*10 + " ")*len(headers)

   def row(self,rowdata):
       '''
       Emit a single row of table data.
       '''
       for d in rowdata:
           print "%10s" % d,
       print
</pre>
</td></tr></table>
</blockquote>

<p>
Now, modify the <tt>print_table()</tt> method so that it calls
<tt>headings()</tt> and <tt>row()</tt> methods to produce its output.
If you run your new program, the output should be exactly the same
as before.
</p>

<p>
<b>(c) Using Inheritance to Produce Different Output</b>
</p>

<p>
By placing the output functionality into separate methods, those
methods can now be overridden via inheritance.    Define a class
<tt>CSVPortfolioPrinter</tt> that produces output in CSV format:
</p>

<blockquote>
<table><tr><td>
<pre>
# stock.py
...
class CSVPortfolioPrinter(PortfolioPrinter):
    '''
    Output portfolio data in CSV format.
    '''
    def headings(self,headers):
        print ",".join(headers)

    def row(self,rowdata):
        print ",".join(rowdata)
</pre>
</td></tr></table>
</blockquote>

<p>
Now, modify your main program as follows:
</p>

<blockquote>
<table><tr><td>
<pre>
if __name__ == '__main__':
    portfolio = read_portfolio("Data/portfolio.dat")
    printer = CSVPortfolioPrinter()
    printer.print_table(portfolio)
</pre>
</td></tr></table>
</blockquote>

<p>
When you run this version of code, you should see CSV output like
this:
</p>

<blockquote>
<pre>
Name,Shares,Price
AA,100,32.20
IBM,50,91.10
CAT,150,83.44
MSFT,200,51.23
GE,95,40.37
MSFT,50,65.10
IBM,100,70.44
</pre>
</blockquote>

<p>
Using a similar idea, define a class <tt>HTMLPortfolioPrinter</tt>
that produces a table with the following output:
</p>

<blockquote>
<pre>
&lt;tr> &lt;th>Name&lt;/th> &lt;th>Shares&lt;/th> &lt;th>Price&lt;/th> &lt;/tr>
&lt;tr> &lt;td>AA&lt;/td> &lt;td>100&lt;/td> &lt;td>32.20&lt;/td> &lt;/tr>
&lt;tr> &lt;td>IBM&lt;/td> &lt;td>50&lt;/td> &lt;td>91.10&lt;/td> &lt;/tr>
</pre>
</blockquote>

<p>
Test your code by modifying the main program to create a
<tt>HTMLPortfolioPrinter</tt> object instead of a
<tt>CSVPortfolioPrinter</tt> object.</p>

<p>
<b>(d) Polymorphism in Action</b>

<p>
A major feature of object-oriented programming is that you can simply plug an object into a program
and it will work without having to change any of the existing code.   For example, if you wrote a program
that expected to use a <tt>PortfolioPrinter</tt> object, it would work no matter what kind of <tt>PortfolioPrinter</tt>
you actually gave it.  This behavior is sometimes referred to as "polymorphism."
</p>

<p>
Modify your main program so that it asks the user for the output
format, creates an appropriate printer object, and uses it to
produce the final output.</p>

<blockquote>
<table><tr><td>
<pre>
# stock.py
...
if __name__ == '__main__':
    portfolio = read_portfolio("Data/portfolio.dat")
    fmt = raw_input("Output format [text|csv|html] : ")
    if fmt == 'text':
        printer = PortfolioPrinter()
    elif fmt == 'csv':
        printer = CSVPortfolioPrinter()
    elif fmt == 'html':
        printer = HTMLPortfolioPrinter()
    else:
        raise RuntimeError("Unsupported output format")
    printer.print_table(portfolio)
</pre>
</td></tr></table>
</blockquote>

<p>
When you run this program, you'll see output such as this:
</p>

<blockquote>
<pre>
Output format [text|csv|html] : <b>csv</b>
Name,Shares,Price
AA,100,32.20
IBM,50,91.10
CAT,150,83.44
MSFT,200,51.23
GE,95,40.37
MSFT,50,65.10
IBM,100,70.44
</pre>
</blockquote>

<p>
<b>(e) Factory functions</b>
</p>

<p>
When you have code that selects one of many possible objects as shown
in part (d), it is often easier to define a factory function
instead. Define a function <tt>get_printer(fmt)</tt> that takes a
format string as input and returns an appropriate
<tt>PortfolioPrinter</tt> object.  Here is an example of how it should
work:</p>


<blockquote>
<table><tr><td>
<pre>
# stock.py
...
if __name__ == '__main__':
    portfolio = read_portfolio("Data/portfolio.dat")
    fmt = raw_input("Output format [text|csv|html] : ")
    printer = get_printer(fmt)
    printer.print_table(portfolio)
</pre>
</td></tr></table>
</blockquote>

<b>Discussion:</b>

<p>
The solution to this exercise has numerous potential "design
problems."  For example, why is the task of making tables tightly
coupled with the problem of stock portfolios?  Why does the base class
contain implementation related to plain-text tables?  Wouldn't that be
better placed in a separate <tt>TextPortfolioPrinter</tt> class to be
more consistent with the other classes?</p

<p>Design of classes and use of inheritance is often a non-trivial
problem that would be covered in courses on object-oriented design or
design patterns.  Although such topics are beyond the scope of this
class, click on the "PRACTICUM" link below to see a better solution to
this exercise.</p>

<hr>

<span style="float:right">
[ <a href="prac5_2.html">PRACTICUM</a> ]
</span>

[ <a href="index.html">Index</a> | <a href="soln5_2.html">Solution</a>
| <a href="ex5_1.html">Back</a> | <a href="ex5_3.html">Next</a> ]
</body>
</html>
