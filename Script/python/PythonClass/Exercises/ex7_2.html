<html>
<head>
<title>Python Training Exercises - Exercise 7.2</title>
</head>

<body>
<h1>Exercise 7.2</h1>

<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
  <li>Learn how to use the logging module to record diagnostics</li>
</ul>

<p>
<b>Files Created:</b> <tt>PythonClass/logconfig.py</tt>

<p>
<b>Files Modified:</b>
<ul>
  <li><tt>PythonClass/fieldparse.py</tt></li>
  <li><tt>PythonClass/report.py</tt></li>
</ul>
  

</td>
</tr>
</table>


<p>
<p>
<b>(a) Adding logging to a module</b>

<P>Logging is relatively easy to add to your code.  In this first
part, go back to your <tt>fieldparse.py</tt> library that was used to
parse datafiles.  In that library, there was a <tt>parse()</tt>
function that looked like this:</p>

<blockquote>
<table>
  <tr><td><pre>
# fieldparse.py

def parse(lines,types,names=None,sep=None):
    '''
    Parse a line of column oriented data into a list of dictionaries
    or tuples with type conversion.
    '''
    records = []
    for lineno, line in enumerate(lines,1):
        # Strip whitespace and ignore blank lines
        line = line.strip()
        if line == '':
            continue

        fields = line.split(sep)
        
        # Get rid of double quotes
        fields = [f.strip('"') for f in fields]
        
        try:
            # Apply type conversion to the fields 
            cfields = [converter(value) for converter,value in zip(types,fields)]
        except ValueError as e:
            print "Line %d: Couldn't parse: %s" % (lineno, line)
            print "Line %d: Reason %s" % (lineno, e)
            continue

        # Optionally turn into a dictionary of named fields
        if names is not None:
            record = dict(zip(names,cfields))
        else:
            record = tuple(cfields)

        # Save the record
        records.append(record)

    return records
  </pre>
  </td>
</tr>
</table>
</blockquote>

<p>
In this implementation, <tt>ValueError</tt> exceptions are caught and
ignored.   Instead of doing that, modify the code to log bad lines of
input.  To do this, modify your <tt>fieldparse.py</tt> code so that it
looks like this (changes are highlighted).</p>

<blockquote>
<table>
  <tr><td><pre>
# fieldparse.py

<font color="#0000ff"># Get a logger on which to issue diagnostics.  The __name__ variable                                                                                                 
# contains the module name--so in this case the logger should have                                                                                                   
# the name 'fieldparse'                                                                                                                                              

import logging
log = logging.getLogger(__name__)
</font>

def parse(lines,types,names=None,sep=None):
    '''
    Parse a line of column oriented data into a list of dictionaries
    or tuples with type conversion.
    '''
    records = []
    for lineno, line in enumerate(lines,1):
        # Strip whitespace and ignore blank lines
        line = line.strip()
        if line == '':
            continue

        fields = line.split(sep)
        
        # Get rid of double quotes
        fields = [f.strip('"') for f in fields]
        
        try:
            # Apply type conversion to the fields 
            cfields = [converter(value) for converter,value in zip(types,fields)]
        except ValueError as e:
<font color="#0000ff">            log.warning("Line %d: Couldn't parse: %s", lineno, line)
            log.debug("Line %d: Reason %s", lineno, e)</font>
            continue

        # Optionally turn into a dictionary of named fields
        if names is not None:
            record = dict(zip(names,cfields))
        else:
            record = tuple(cfields)

        # Save the record
        records.append(record)

    return records
  </pre>
  </td>
</tr>
</table>
</blockquote>

<P>
Now that you've made these changes, try using your module
interactively.
</p>

<blockquote>
<pre>
>>> <b>import fieldparse</b>
>>> <b>a = fieldparse.parse(open("Data/portfolio.dat"),[str,int,float])</b>
>>> <b>b = fieldparse.parse(open("Data/portfolio3.dat"),[str,int,float])</b>
No handlers could be found for logger "fieldparse"
>>>
</pre>
</blockquote>
<p>
The warning message about handlers means that a logging message was issued, but
the logging module wasn't configured.   Type these steps to do that and
actually see the warning messages:
</p>

<blockquote>
<pre>
>>> <b>import logging</b>
>>> <b>logging.basicConfig()</b>
>>> <b>b = fieldparse.parse(open("Data/portfolio3.dat"),[str,int,float])</b>
WARNING:fieldparse:Line 4: Couldn't parse: C - 53.08
WARNING:fieldparse:Line 7: Couldn't parse: DIS - 34.20
WARNING:fieldparse:Line 8: Couldn't parse: GE - 37.23
WARNING:fieldparse:Line 9: Couldn't parse: GM - 31.44
...
>>>
</pre>
</blockquote>

<p>
You will notice that you don't see the output from the <tt>log.debug()</tt> operation.  By
default, logging only outputs messages that have a level of <tt>WARNING</tt> or higher.   Type this to
change the level.</p>

<blockquote>
<pre>
>>> <b>logging.getLogger('fieldparse').level = logging.DEBUG</b>
>>> <b>b = fieldparse.parse(open("Data/portfolio3.dat"),[str,int,float])</b>
WARNING:fieldparse:Line 4: Couldn't parse: C - 53.08
DEBUG:fieldparse:Line 4: Reason invalid literal for int() with base 10: '-'
WARNING:fieldparse:Line 7: Couldn't parse: DIS - 34.20
DEBUG:fieldparse:Line 7: Reason invalid literal for int() with base 10: '-'
WARNING:fieldparse:Line 8: Couldn't parse: GE - 37.23
DEBUG:fieldparse:Line 8: Reason invalid literal for int() with base 10: '-'
WARNING:fieldparse:Line 9: Couldn't parse: GM - 31.44
DEBUG:fieldparse:Line 9: Reason invalid literal for int() with base 10: '-'
...
>>>
</pre>
</blockquote>

<p>
Turn off all, but the most critical logging messages:
</p>

<blockquote>
<pre>
>>> <b>logging.getLogger('fieldparse').level=logging.CRITICAL</b>
>>> <b>b = fieldparse.parse(open("Data/portfolio3.dat"),[str,int,float])</b>
>>>
</pre>
</blockquote>

<p>
<b>(b) Adding Logging to an Application</b>
</p>

<p>
To add logging to an application, you need to have some mechanism to initialize the logging module in the main module.  One way to do this is to create a separate module
that's dedicated to setting up logging and importing it into your application.  Create a file <tt>logconfig.py</tt> that has this code:
</p>


<blockquote>
<table>
  <tr><td><pre>
# logconfig.py
#
# This file simply sets up basic configuration of the logging module.
# Change settings here to adjust logging output as needed.   
import logging
logging.basicConfig(
    filename = 'app.log',         # Name of the log file (omit to use stderr)
    filemode = 'w',               # File mode (use 'a' to append)
    level    = logging.WARNING,   # Logging level (DEBUG, INFO, WARNING, ERROR, or CRITICAL)
)
 </pre>
  </td>
</tr>
</table>
</blockquote>

<p>
Now, in applications where you want to use logging, simply make sure you import <tt>logconfig.py</tt>.  For example, modify your <tt>report.py</tt>
program like this:
</p>

<blockquote>
<table>
  <tr><td><pre>
# report.py
...
if __name__ == '__main__':
<font color="#0000ff">    import logconfig</font>
    portfolio_report("Data/portfolio3.dat",
                     "Data/prices.csv")
</pre>
  </td>
</tr>
</table>
</blockquote>

<p>
Make this modification to <tt>report.py</tt> and experiment with the
modified version.   Try changing the logging levels and viewing the
resulting log file.  In IDLE, you can easily print out the log doing this:
</p>

<blockquote>
<pre>
>>> <b>print open("app.log").read()</b>
... look at the output ...
>>>
</pre>
</blockquote>


<p>
<b>Commentary</b>
</p>

<p>
The logging module has a large number of advanced features and configuration options.   More information can be found in <a href="../Optional/Logging.pdf">PythonClass/Optional/Logging.pdf</a>.
</p>

<hr>
[ <a href="index.html">Index</a> | <a href="soln7_2.html">Solution</a>
| <a href="ex7_1.html">Back</a> | <a href="ex7_3.html">Next</a> ]
</body>
</html>
