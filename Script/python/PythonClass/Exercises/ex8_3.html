<html>
<head>
<title>Python Training Exercises - Exercise 8.3</title>
</head>

<body>
<h1>Exercise 8.3</h1>

<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
<li>Using generators to set up processing pipelines
</ul>

<p>
<b>Files Created:</b> None

<p>
<b>Files Modified:</b> <tt>PythonClass/follow.py</tt>

</td>
</tr>
</table>

<p>
Note: For this exercise the stocksim.py program should still be
running in the background.  You're going to use the <tt>follow()</tt>
function you wrote in the previous exercise.

<p><b>Tip:</b> There is potentially a lot of typing in this exercise. You'll probably want to cut and paste most of the
code samples and examples.

<p>
<b>(a) Setting up a processing pipeline</b>

<p>
A major power of generators is that they allow you to create programs that set up
processing pipelines--much like pipes on Unix systems.  Experiment with this concept by
adding some functionality to your <tt>follow.py</tt> program.  Follow these steps carefully:

<p>
In your file <tt>follow.py</tt>, define the following function:
</p>

<blockquote>
<table><tr><td><pre>
# follow.py
...
def splitter(lines):
    '''
    Split a sequence of lines containing CSV data into a sequence of rows.
    '''
   for line in lines:
        yield line.split(',')
</pre></td></tr></table>
</blockquote>

This generator loops over a sequence of lines such as the following:

<blockquote><pre>
'"AIG",71.95,"6/11/2007","14:12.34",0.42,71.29,71.98,71.26,3136489'
</pre></blockquote>

Each line is simply split into a list of strings like this:

<blockquote><pre>
['"AIG"', '71.95', '"6/11/2007"', '"14:12.34"', '0.42', '71.29', '71.98', '71.26', '3136489']
</pre></blockquote>

Try hooking up this function to your <tt>follow()</tt> function from earlier:

<blockquote>
<pre>
>>> <b>lines = follow("Data/stocklog.dat")</b>
>>> <b>rows = splitter(lines)</b>
>>> <b>for r in rows:</b>
    <b>    print r</b>

... watch the output ...
</pre>
</blockquote>

Try to wrap your brain around what's happening here.  Basically, the <tt>follow()</tt> generator
is producing lines which are then fed into a generator <tt>splitter()</tt>.  That generator, in
turn is producing a <b>sequence of rows</b> where each row is a list of
the different columns of data.

<p>
<b>(b) Making more pipeline components</b>

<p>
Add the following generator function to your <tt>follow.py</tt> program.

<blockquote>
<table><tr><td><pre>
# follow.py
...
def make_records(rows,names):
    '''
    Turn a sequence of rows into a sequence of dictionaries.
    '''
    for row in rows:
        yield dict(zip(names,row))
</pre></td></tr></table>
</blockquote>

This generator takes a row list such as this:

<blockquote><pre>
['"AIG"', '71.95', '"6/11/2007"', '"14:12.34"', '0.42', '71.29', '71.98', '71.26', '3136489']
</pre></blockquote>

and turns it into a dictionary:

<blockquote><pre>
{'name':'"AIG"', 'price':'71.95', 'date':'"6/11/2007"', 'time':'"14:12.34"',
 'change': '0.42', 'open':'71.29', 'high':'71.98', 'low':'71.26', 'volume':'3136489'}
</pre></blockquote>

<p>
Try your new generator function:

<blockquote>
<pre>
>>> <b>lines = follow("Data/stocklog.dat")</b>
>>> <b>rows = splitter(lines)</b>
>>> <b>records = make_records(rows,['name','price','date','time','change','open','high','low','volume'])</b>
>>> <b>for r in records:</b>
    <b>    print r</b>

... watch the output ...
</pre>
</blockquote>

<p>
<b>(c) Transforming data</b>

<p>
Let's write some generator functions that transform various fields
of the dictionaries being generated in part (b).  Add these functions
to your <tt>follow.py</tt> program:

<blockquote>
<table><tr><td><pre>
# follow.py
...

def unquote(records,keylist):
    '''
    Unquote the value of selected keys in a sequence of dictionaries.
    '''
    for r in records:
        for key in keylist:
            r[key] = r[key].strip('"')
        yield r

def convert(records,converter,keylist):
    '''
    Apply type conversion to the value of selected keys in a sequence of dictionaries.
    '''
    for r in records:
        for key in keylist:
            r[key] = converter(r[key])
        yield r
</pre></td></tr></table>
</blockquote>

Try these new functions out as follows:


<blockquote>
<pre>
>>> <b>lines = follow("Data/stocklog.dat")</b>
>>> <b>rows = splitter(lines)</b>
>>> <b>records = make_records(rows,['name','price','date','time','change','open','high','low','volume'])</b>
>>> <b>records = unquote(records,['name','date','time'])</b>
>>> <b>records = convert(records,float,['price','change','open','high','low'])</b>
>>> <b>records = convert(records,int,['volume'])</b>
>>> <b>for r in records:</b>
    <b>    print r</b>

... watch the output ...
</pre>
</blockquote>

<p>
Here, you're starting to see a lot of different processing elements stacked together.  Again,
keep in mind that each generator is merely processing a stream of data.

<p>
<b>(d) Packaging</b>

<p>
Take the different steps you tried in the last example and put them into a function:

<blockquote>
<table><tr><td><pre>
# follow.py
...
def parse_stock_data(lines):
    '''
    Take a sequence of lines and produce a sequence of dictionaries containing stock market data.
    '''
    rows = splitter(lines)
    records = make_records(rows,['name','price','date','time',
                              'change','open','high','low','volume'])
    records = unquote(records,["name","date","time"])
    records = convert(records,float,['price','change','open','high','low'])
    records = convert(records,int,['volume'])
    return records
</pre></td></tr></table>
</blockquote>

Now, try this new function and print a nicely formatted stock ticker:

<blockquote>
<pre>
>>> <b>lines = follow("Data/stocklog.dat")</b>
>>> <b>records = parse_stock_data(lines)</b>
>>> <b>for r in records:
        print "%(name)10s %(price)10.2f %(change)10.2f %(volume)10d" % r</b>

... watch the output ...
</pre>
</blockquote>

<p>
Some lessons learned: You can create various generator functions and
chain them together to perform processing involving data-flow
pipelines.  In addition, you can create functions that package a
series of pipeline stages into a single function call (for example,
the <tt>parse_stock_data()</tt> function).</p>


<hr>


<span style="float:right">
[ <a href="prac8_3.html">PRACTICUM</a> ]
</span>

[ <a href="index.html">Index</a> | <a href="soln8_3.html">Solution</a>
| <a href="ex8_2.html">Back</a> | <a href="ex8_4.html">Next</a> ]
</body>
</html>
