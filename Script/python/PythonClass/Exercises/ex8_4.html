<html>
<head>
<title>Python Training Exercises - Exercise 8.4</title>
</head>

<body>
<h1>Exercise 8.4</h1>

<table width=600 bgcolor="#e0e0ff" border=1 cellpadding=20>
<tr>
<td>
<b>Objectives:</b>
<ul>
<li>Introduction to generator expressions--a generator version of a list comprehension.
</ul>

<p>
<b>Files Created:</b> None</p>

<p>
<b>Files Modified:</b> None</p>

</td>
</tr>
</table>

<p>

In <a href="ex8_3.html">Exercise 8.3</a> you wrote some code that followed lines being written to a log file
and parsed them into a sequence of records.  For example:

<blockquote>
<pre>
>>> <b>lines = follow("Data/stocklog.dat")</b>
>>> <b>records = parse_stock_data(lines)</b>
>>> <b>for r in records:</b>
    <b>    print r</b>

... watch the output (it might take 30 seconds for data to appear) ...
</pre>
</blockquote>

In this exercise, we're going to further experiment with generators by writing some generator expressions
that perform queries on the sequence of records being generated by the <tt>parse_stock_data()</tt> function.

<p>
<b>(a) Generator Expressions</b>

<P>
Write a generator expression that only produces records for stocks that have a negative change:

<blockquote>
<pre>
>>> <b>lines = follow("Data/stocklog.dat")</b>
>>> <b>records = parse_stock_data(lines)</b>
>>> <b>records = (r for r in records if r['change'] < 0)</b>
>>> <b>for r in records:
        print "%(name)10s %(price)10.2f %(change)10.2f %(volume)10d" % r</b>

... watch the output ...
</pre>
</blockquote>

In this example, the final <tt>records</tt> variable is another generator--it does not create a
fully populated list like a list comprehension.

<p>
<b>(b) Generator Expressions in Function Arguments</b>

<p>
Generator expressions are sometimes placed into function arguments.
It looks a little weird at first, but try this experiment:</p>

<p>
<blockquote>
<pre>
>>> <b>nums = [1,2,3,4,5]</b>
>>> <b>sum([x*x for x in nums])</b>    # A list comprehension
55
>>> <b>sum(x*x for x in nums)</b>      # A generator expression
55
>>>
</pre>
</blockquote>

<p>
In the above example, the second version using generators typically uses far less memory.</p>

<p>Try this tricky problem involving string joins:</p>

<blockquote>
<pre>
>>> <b>row = ('GOOG', 100, 490.1)</b>
>>> <b>print ','.join(row)</b>
Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: sequence item 1: expected string, int found
>>>
</pre>
</blockquote>

<p>
It doesn't work because some of the tuple items are non-strings.   Try
this version that converts each item:
</p>
<blockquote>
<pre>
>>> <b>print ','.join(str(r) for r in row)</b>
GOOG,100,490.1
>>>
</pre>
</blockquote>

<p>
Try the following statement which gathers a set of all unique stock symbols in a
stock portfolio.

<blockquote>
<pre>
>>> <b>symbols = set(line.split()[0] for line in open("Data/portfolio.dat"))</b>
>>> <b>symbols</b>
set(['AA', 'GE', 'IBM', 'MSFT', 'CAT'])
>>>
</pre>
</blockquote>

In this example, <tt>set()</tt> creates a set of unique items in a sequence.  The
argument to <tt>set()</tt> is a generator expression that loops over lines in
a file, splits each line, and extracts a specific column.  The advantage to using
a generator here is that it doesn't read the entire file into any kind of
temporary data structure.  Instead, the sequence being fed into to the <tt>set()</tt>
function is being generated incrementally.

<p>
<b>(c) Generator Expressions as Filters</b>
</p>

<p>
Generator expressions are a convenient way to filter streams of data
such as a file.   For example, try this:
</p>

<blockquote>
<pre>
>>> <b>with open("Data/stocklog.dat") as f:</b>
        <b>lines = (line for line in f if 'IBM' in line)</b>
        <b>for line in lines:
            print line,</b>

... look at the output ...
</pre>
</blockquote>

<hr>
[ <a href="index.html">Index</a> | <a href="soln8_4.html">Solution</a>
| <a href="ex8_3.html">Back</a> | <a href="ex9_1.html">Next</a> ]
</body>
</html>
