<html>
<head>
<title>Practicum - Exercise 5.2</title>
</head>

<body>
<h1>Practicum - Exercise 5.2</h1>

<p>
<b>Keeping Things Decoupled</b>
</p>

<p>
A major problem with the solution to exercise 5.2 is that the different output
formats (Text, CSV, HTML) are tightly coupled to the task of printing
a portfolio of stocks.   However, making tables in different formats
is actually a fairly general problem--something that might be done to
produce all sorts of different tables.
</p>

<p>
To generalize the output code, you might take a different strategy. In
a separate file <tt>tableformat.py</tt>, define the following base
class:
</p>

<blockquote>
<table><tr><td>
<pre>
# tableformat.py

class TableHandler(object):
    # Produce table headers
    def headings(self,headers):
        pass
    # Produce a single row of table output
    def row(self,rowdata):
        pass
</pre>
</td></tr></table>
</blockquote>

<p>
Now, define three classes <tt>TextTableHandler</tt>,
<tt>CSVTableHandler</tt>, and <tt>HTMLTableHandler</tt> that all
inherit from the <tt>TableHandler</tt> base class.  In these classes,
define the <tt>headings()</tt> and <tt>row()</tt> methods exactly the
same as before (just cut and paste the code).
</p>

<p>
Here is an example:
</p>

<blockquote>
<table><tr><td>
<pre>
# tableformat.py

...
class TextTableHandler(TableHandler):
   def headings(self,headers):
        for h in headers:
            print "%10s" % h,
            print
        print ("-"*10 + " ")*len(headers)
   def row(self,rowdata):
        for d in rowdata:
            print "%10s" % d,
        print
</pre>
</td></tr></table>
</blockquote>

<P>
Once you have defined these classes, modify the
<tt>PortfolioPrinter</tt> class so that it performs its output using a
<tt>TableHandler</tt> object.  Modify the code like this:
</p>

<blockquote>
<table><tr><td>
<pre>
# stock.py
...
class PortfolioPrinter(object):
    def __init__(self,handler):
        self.handler = handler
    def print_table(self,portfolio):
        self.handler.headings(['Name','Shares','Price'])
        for s in portfolio:
            self.handler.row([s.name,"%d" % s.shares, "%0.2f" % s.price])
</pre>
</td></tr></table>
</blockquote>

<p>
Finally, rewire your main program so that it uses the handler objects
defined in the <tt>tableformat.py</tt> file:
</p>

<blockquote>
<table><tr><td>
<pre>
if __name__ == '__main__':
   import tableformat
   portfolio = read_portfolio("Data/portfolio.dat")
   format = raw_input("Output format [text|csv|html] : ")
   if format == 'text':
       handler = tableformat.TextTableHandler()
   elif format == 'csv':
       handler = tableformat.CSVTableHandler()
   elif format == 'html':
       handler = tableformat.HTMLTableHandler()
   else:
       raise RuntimeError("Unsupported output format")
   printer = PortfolioPrinter(handler)
   printer.print_table(portfolio)
</pre>
</td></tr></table>
</blockquote>

<p>
<b>Discussion:</b>
</p>

<p>
If you see how the various parts of this exercise work and fit together, then you
already understand just about everything you're ever going to need to know
about object oriented programming to use various Python library
modules and extensions.   There are really just two big ideas.  First,
inheritance is a tool that is used to customize and extend
existing objects--in certain libraries you might be asked to define
your own class that inherits from a specified base class and defines some
set of required methods.   The use of special handler objects as shown
here is also a commonly used programming structure.  For example, a library
might require you to implement your own handler object that gets
plugged into other functions and classes in the library.</p>

<p>
Don't be misled into thinking that designing classes is easy--it's
not.  Knowing how (and when) to use inheritance, handlers, and other
design techniques is non-trivial.  Moreover, when you get it wrong,
your programming experience usually becomes quite painful.  For more
information, get a book that discusses "Design Patterns." </p>


<p>
<b>Challenge Problem: Reports and command line options</b>
</p>

<p>
Modify your <tt>report.py</tt> program so that it uses the
tableformatting code that you just wrote.  In addition, make it so
that the output format can
be optionally specified on the command line using a <tt>-f fmt</tt> option.   For example:
</p>


<blockquote>
<pre>
bash % <b>python report.py Data/portfolio.dat Data/prices.csv</b>
      Name     Shares      Price     Change 
---------- ---------- ---------- ---------- 
        AA        100       9.22     -22.98
       IBM         50     106.28      15.18
       CAT        150      35.46     -47.98
      MSFT        200      20.89     -30.34
        GE         95      13.48     -26.89
      MSFT         50      20.89     -44.21
       IBM        100     106.28      35.84
bash % <b>python report.py -f csv Data/portfolio.dat Data/prices.csv</b>
Name,Shares,Price,Change
AA,100,9.22,-22.98
IBM,50,106.28,15.18
CAT,150,35.46,-47.98
MSFT,200,20.89,-30.34
GE,95,13.48,-26.89
MSFT,50,20.89,-44.21
IBM,100,106.28,35.84
bash %
</pre>
</blockquote>

<p>
To solve this problem, you might consider the use of the
<tt>optparse</tt> or <tt>argparse</tt> libraries.  Consult the Python
library documentation for hints.
</p>


</body>
</html>
